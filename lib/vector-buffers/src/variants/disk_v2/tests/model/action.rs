use proptest::{
    arbitrary::any,
    collection::{vec as arb_vec, SizeRange},
    prop_oneof,
    strategy::Just,
    strategy::Strategy,
};

use super::record::Record;

/// Input action for the model/system under test.
///
/// These actions map directly to methods that can be called from the reader, writer, or acker.
///
/// One notable difference compared to the real types is that acknowledgements here are only
/// allowed to acknowledge one read at a time.
///
/// TODO: Update `AcknowledgeRead` to be parameterized for acknowledging multiple reads at a time,
/// and update the santization method to constrain those amounts to the number of outstanding
/// unacknowledged reads based on the action sequence.
#[derive(Clone, Debug)]
pub enum Action {
    WriteRecord(Record),
    FlushWrites,
    ReadRecord,
    AcknowledgeRead,
}

impl Action {
    pub fn is_write(&self) -> bool {
        match self {
            Self::WriteRecord(_) | Action::FlushWrites => true,
            _ => false,
        }
    }

    pub fn is_read(&self) -> bool {
        match self {
            Self::ReadRecord => true,
            _ => false,
        }
    }

    pub fn is_ack(&self) -> bool {
        match self {
            Self::AcknowledgeRead => true,
            _ => false,
        }
    }
}

fn arb_action() -> impl Strategy<Value = Action> {
    // Overall, we want reads and writes to be equal, with slightly fewer acks, and slightly fewer
    // still flushes of writes.
    prop_oneof![
        3 => Just(Action::FlushWrites),
        5 => Just(Action::ReadRecord),
        4 => Just(Action::AcknowledgeRead),
        5 => any::<(u32, u16, u8)>().prop_map(|(id, base_size, size_offset)| {
            let size = base_size as u32 + size_offset as u32;
            Action::WriteRecord(Record::new(id, size))
        }),
    ]
}

pub fn arb_actions<R>(len_range: R) -> impl Strategy<Value = Vec<Action>>
where
    R: Into<SizeRange>,
{
    arb_vec(arb_action(), len_range)
}

/// Sanitizes raw actions generated by QuickCheck into a valid sequence.
///
/// While we obviously want QuickCheck to generate randomized orderings of actions to exercise our
/// model and our system under test (SUT), there are certain combinations/orderings that are simply
/// not valid.  For example, an acknowledgement is only generated by the user of a buffer once
/// they've gotten a record from a `read` operation, so allowing an acknowledgement to exist in an
/// action sequence where there is no read is not valid and never will be.  There is no reason to
/// test such a sequence.
pub fn sanitize_raw_actions(actions: Vec<Action>) -> Vec<Action> {
    let mut outstanding_reads = 0;
    actions
        .into_iter()
        .filter(|a| {
            // If there's a read, we add it to our outstanding read total.
            if a.is_read() {
                outstanding_reads += 1;
                true
            } else if a.is_ack() {
                // If we see an acknowledgement action, there has to be an outstanding read that it
                // can pair with, otherwise things would be unbalanced.
                if outstanding_reads == 0 {
                    false
                } else {
                    outstanding_reads -= 1;
                    true
                }
            } else {
                // Everything else can pass through untouched.
                true
            }
        })
        .collect::<Vec<_>>()
}
