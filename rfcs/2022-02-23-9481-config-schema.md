# RFC 9481 - 2022-02-23 - Configuration Schema

Vector's configuration, while driven by code, is hard to document, as well as programmatically
describe and validate outside of Vector itself.  This RFC proposes an enhancement to how we define
configuration types so that Vector can emit an authoritative schema that can be used to drive
configuration editing and validation, in both interactive and programmatic contexts.

## Context

- Document options naming and remediate [#3714](https://github.com/vectordotdev/vector/issues/3714)
- Formalize how options are deprecated [#4023](https://github.com/vectordotdev/vector/issues/4023)
- Versioned Vector configuraton [#6231](https://github.com/vectordotdev/vector/issues/6231)
- Fix broken handling of adaptive_concurrency defaults [#8189](https://github.com/vectordotdev/vector/issues/8189)
- Fuzz/validate Vector's configuration options [#8229](https://github.com/vectordotdev/vector/issues/8229)
- ARC was not enabled by default [#9727](https://github.com/vectordotdev/vector/issues/9727)
- Avoid enum deserialization for configuration [#10582](https://github.com/vectordotdev/vector/issues/10582)

## Cross cutting concerns

- This work will eventually help power the UI for Datadog's Observability Pipelines, in terms of validating
  user-supplied configurations.  We want to be cognizant of areas where we can provide more
  flexibility/generalization to allow that work to extract whatever information it may require.
- There are many potentially off-label usages of the configuration schema -- configuration migration, generative
  testing, and so on -- where we'll be balancing a fine-line between encoding our configuration
  schema as an API contract vs encoding it as a representation of implementation details.

## Scope

### In scope

- Encoding the schema of Vector's configuration.
- Modifications to how configuration types are created and used to provide invariants that make
  generating such a schema easier.

### Out of scope

- Providing the configuration schema as part of a Vector release.
- Providing additional tooling, or enhancements to existing tooling, to use the schema to help
  better validate configurations.
- Generating Cue documentation from the configuration schema.
- Generating configuration migrations between versions of Vector.

## Pain

Vector's configuration represents a fairly dense entrypoint into the vast flexibility provided by
Vector: sources, transforms, sinks, tests, each with their own varying levels of complexity.

While Vector's documentation is generally fairly high-quality, users struggle to efficiently and
correctly configure Vector for a variety of different reasons:
- lack of available examples
- incorrectly documented fields, or lack of documentation of fields
- confusion over field types and supported values (i.e. a field that can be a string or object)
- human-unfriendly rendering of default values (i.e. `1e+07` instead of `1000000`, even when we know
  the unit is bytes, and could instead display `1MB`)

Additionally, some of these pains are also pains felt during development.  While users may struggle
to understand an issue caused by following incorrect documentation, developers also struggle to
correctly update the Cue documentation that Vector users.  While Cue itself is a powerful data
constraint language, it can take time to master and can be similarly inscrutable when errors are
encountered.  Overlapping with some of the user pains, understanding when the documentation needs to
be updated, or even simply remembering, can easily be missed during development, which in turn leads
to documentation that grows out-of-sync until someone realizes what has occurred.

## Proposal

### User Experience

In order to address these concerns, we would update Vector to generate a configuration schema to
provide a single source of truth in terms of how a particular version of Vector could be configured.

As a developer, the primary impact of this would be in terms of needing to utilize any new helpers,
or patterns, that became required for documenting their configuration types.  We would add these new
helpers, and where necessary, validate their usage.

In turn, developers could expect something akin to a a new CI check or lint being added that told
them when their code did not comply, and what changes needed to be made in order to do so.

Overall, the cognitive overhead of this proposal would be low, as we would rely on the compiler, and
CI, as much as possible in order to surface errors or non-compliance and explain exactly what needed
to be changed in order to fix the errors.

### Implementation

#### 1. Introduce a new trait and custom derive macro: `Configuration`

This trait, and derive macro, would form the basis of validating the compliance of a configuration
as well as walking a configuration to generate its schema. There are two primary requirements for
generating the configuration schema: discoverability and compliance.

**Discoverability**, or the actual logic of inspecting the configuration types, encoding information
about their fields, allowable values, and so on, is the most obvious requirement.  We need to be
able to find these types, know they can be inspected, and then actually do the work. **Compliance** is
perhaps even more important: unless all configuration types are able to be inspected, then the
configuration schema can never be used to correctly validate a user-supplied configuration.

The `Configuration` trait would form the basis for discoverability.  It would provide a minimalistic
interface that walked the type, and walked its fields, mapping closely to the traditional "Visitor"
pattern.  The trait would allow exposing common items such as name, description, allowable type,
units, and so on.  Additionally, it would allow for defining custom metadata, or extensions, that
could be parsed by external code to satisfy more advanced workflows i.e. configuration migration,
testing, etc.



## Rationale

- Why is this change worth it?
- What is the impact of not doing this?
- How does this position us for success in the future?

## Drawbacks

- Why should we not do this?
- What kind on ongoing burden does this place on the team?

## Prior Art

- List prior art, the good and bad.
- Why can't we simply use or copy them?

## Alternatives

- What other approaches have been considered and why did you not choose them?
- How about not doing this at all?

## Outstanding Questions

- List any remaining questions.
- Use this to resolve ambiguity and collaborate with your team during the RFC process.
- *These must be resolved before the RFC can be merged.*

## Plan Of Attack

Incremental steps to execute this change. These will be converted to issues after the RFC is approved:

- [ ] Submit a PR with spike-level code _roughly_ demonstrating the change.
- [ ] Incremental change #1
- [ ] Incremental change #2
- [ ] ...

Note: This can be filled out during the review process.

## Future Improvements

- List any future improvements. Use this to keep your "plan of attack" scope small and project a sound design.
